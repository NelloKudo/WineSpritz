From ada04aedbbf6489d395441aa5893e9d1f8ac2d7f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 8 Sep 2024 15:12:20 +0200
Subject: [PATCH 1/4] server: Remove unused get_window_info atom reply
 parameter.

---
 server/protocol.def | 1 -
 server/window.c     | 1 -
 2 files changed, 2 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 4f712b4e4e6..cc658915da0 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2573,7 +2573,6 @@ enum message_type
     user_handle_t  last_active; /* last active popup */
     process_id_t   pid;         /* process owning the window */
     thread_id_t    tid;         /* thread owning the window */
-    atom_t         atom;        /* class atom */
     int            is_unicode;  /* ANSI or unicode */
     unsigned int   dpi_context; /* window DPI context */
 @END
diff --git a/server/window.c b/server/window.c
index f7f9d5e517f..afd4564e206 100644
--- a/server/window.c
+++ b/server/window.c
@@ -2331,7 +2331,6 @@ DECL_HANDLER(get_window_info)
     {
         reply->tid  = get_thread_id( win->thread );
         reply->pid  = get_process_id( win->thread->process );
-        reply->atom = win->class ? get_class_atom( win->class ) : DESKTOP_ATOM;
     }
 }
 
-- 
GitLab


From db582779e5d9a8ecdda6a6f3374ed21d69149b1e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 8 Sep 2024 14:00:29 +0200
Subject: [PATCH 2/4] server: Introduce shared session objects for windows.

---
 dlls/win32u/win32u_private.h |  1 +
 dlls/win32u/window.c         |  4 ++++
 dlls/win32u/winstation.c     | 38 +++++++++++++++++++++++++++++++++++-
 server/protocol.def          | 25 ++++++++++++++++--------
 server/window.c              | 26 ++++++++++++++++++++++--
 5 files changed, 83 insertions(+), 11 deletions(-)

diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index b4738ed6b16..3bdfa47b439 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -222,6 +222,7 @@ struct object_lock
 extern NTSTATUS get_shared_desktop( struct object_lock *lock, const desktop_shm_t **desktop_shm );
 extern NTSTATUS get_shared_queue( struct object_lock *lock, const queue_shm_t **queue_shm );
 extern NTSTATUS get_shared_input( UINT tid, struct object_lock *lock, const input_shm_t **input_shm );
+extern void set_shared_user_object( HANDLE handle, struct obj_locator locator );
 
 extern BOOL is_virtual_desktop(void);
 
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 1cea6d25a4b..6dbfaebb497 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -5305,6 +5305,7 @@ static WND *create_window_handle( HWND parent, HWND owner, UNICODE_STRING *name,
     UINT dpi_context = get_thread_dpi_awareness_context();
     HWND handle = 0, full_parent = 0, full_owner = 0;
     struct tagCLASS *class = NULL;
+    struct obj_locator locator;
     int extra_bytes = 0;
     WND *win;
 
@@ -5320,6 +5321,7 @@ static WND *create_window_handle( HWND parent, HWND owner, UNICODE_STRING *name,
             wine_server_add_data( req, name->Buffer, name->Length );
         if (!wine_server_call_err( req ))
         {
+            locator     = reply->locator;
             handle      = wine_server_ptr_handle( reply->handle );
             full_parent = wine_server_ptr_handle( reply->parent );
             full_owner  = wine_server_ptr_handle( reply->owner );
@@ -5348,6 +5350,8 @@ static WND *create_window_handle( HWND parent, HWND owner, UNICODE_STRING *name,
         return NULL;
     }
 
+    set_shared_user_object( handle, locator );
+
     if (!parent)  /* if parent is 0 we don't have a desktop window yet */
     {
         struct ntuser_thread_info *thread_info = NtUserGetThreadInfo();
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index b350b706454..5850f1121f0 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -52,6 +52,12 @@ struct shared_input_cache
     DWORD tid;
 };
 
+struct shared_user_object_cache
+{
+    const shared_object_t *object;
+    UINT64 id;
+};
+
 struct session_thread_data
 {
     const shared_object_t *shared_desktop;         /* thread desktop shared session cached object */
@@ -328,6 +334,26 @@ NTSTATUS get_shared_input( UINT tid, struct object_lock *lock, const input_shm_t
     return status;
 }
 
+#define NB_USER_HANDLES  ((LAST_USER_HANDLE - FIRST_USER_HANDLE + 1) >> 1)
+#define USER_HANDLE_TO_INDEX(handle) ((LOWORD(handle) - FIRST_USER_HANDLE) >> 1)
+
+static struct shared_user_object_cache user_objects[NB_USER_HANDLES];
+static pthread_mutex_t user_objects_lock = PTHREAD_MUTEX_INITIALIZER;
+
+void set_shared_user_object( HANDLE handle, struct obj_locator locator )
+{
+    WORD index = USER_HANDLE_TO_INDEX( handle );
+    struct shared_user_object_cache *cache;
+
+    if (index >= NB_USER_HANDLES) return;
+    cache = user_objects + index;
+
+    pthread_mutex_lock( &user_objects_lock );
+    cache->id = locator.id;
+    cache->object = find_shared_session_object( locator );
+    pthread_mutex_unlock( &user_objects_lock );
+}
+
 BOOL is_virtual_desktop(void)
 {
     struct object_lock lock = OBJECT_LOCK_INIT;
@@ -777,6 +803,7 @@ HWND get_desktop_window(void)
     static const WCHAR wine_service_station_name[] =
         {'_','_','w','i','n','e','s','e','r','v','i','c','e','_','w','i','n','s','t','a','t','i','o','n',0};
     struct ntuser_thread_info *thread_info = NtUserGetThreadInfo();
+    struct obj_locator top_locator, msg_locator;
     WCHAR name[MAX_PATH];
     BOOL is_service;
 
@@ -796,6 +823,8 @@ HWND get_desktop_window(void)
         {
             thread_info->top_window = reply->top_window;
             thread_info->msg_window = reply->msg_window;
+            top_locator = reply->top_locator;
+            msg_locator = reply->msg_locator;
         }
     }
     SERVER_END_REQ;
@@ -878,13 +907,20 @@ HWND get_desktop_window(void)
             {
                 thread_info->top_window = reply->top_window;
                 thread_info->msg_window = reply->msg_window;
+                top_locator = reply->top_locator;
+                msg_locator = reply->msg_locator;
             }
         }
         SERVER_END_REQ;
     }
 
     if (!thread_info->top_window) ERR_(win)( "failed to create desktop window\n" );
-    else user_driver->pSetDesktopWindow( UlongToHandle( thread_info->top_window ));
+    else
+    {
+        set_shared_user_object( UlongToHandle( thread_info->top_window ), top_locator );
+        set_shared_user_object( UlongToHandle( thread_info->msg_window ), msg_locator );
+        user_driver->pSetDesktopWindow( UlongToHandle( thread_info->top_window ));
+    }
 
     register_builtin_classes();
     return UlongToHandle( thread_info->top_window );
diff --git a/server/protocol.def b/server/protocol.def
index cc658915da0..44e952ecc91 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1007,11 +1007,17 @@ typedef volatile struct
     int                  keystate_lock;    /* keystate is locked */
 } input_shm_t;
 
+typedef volatile struct
+{
+    int                  placeholder;
+} window_shm_t;
+
 typedef volatile union
 {
     desktop_shm_t        desktop;
     queue_shm_t          queue;
     input_shm_t          input;
+    window_shm_t         window;
 } object_shm_t;
 
 typedef volatile struct
@@ -2531,12 +2537,13 @@ enum message_type
     unsigned int   ex_style;    /* window extended style */
     VARARG(class,unicode_str);  /* class name */
 @REPLY
-    user_handle_t  handle;      /* created window */
-    user_handle_t  parent;      /* full handle of parent */
-    user_handle_t  owner;       /* full handle of owner */
-    int            extra;       /* number of extra bytes */
-    client_ptr_t   class_ptr;   /* pointer to class in client address space */
-    unsigned int   dpi_context; /* window DPI context */
+    struct obj_locator  locator;     /* locator for the shared session object */
+    user_handle_t       handle;      /* created window */
+    user_handle_t       parent;      /* full handle of parent */
+    user_handle_t       owner;       /* full handle of owner */
+    int                 extra;       /* number of extra bytes */
+    client_ptr_t        class_ptr;   /* pointer to class in client address space */
+    unsigned int        dpi_context; /* window DPI context */
 @END
 
 
@@ -2550,8 +2557,10 @@ enum message_type
 @REQ(get_desktop_window)
     int            force;       /* force creation if it doesn't exist */
 @REPLY
-    user_handle_t  top_window;  /* handle to the desktop window */
-    user_handle_t  msg_window;  /* handle to the top-level HWND_MESSAGE parent */
+    user_handle_t       top_window;  /* handle to the desktop window */
+    user_handle_t       msg_window;  /* handle to the top-level HWND_MESSAGE parent */
+    struct obj_locator  top_locator; /* locator for the desktop window shared session object */
+    struct obj_locator  msg_locator; /* locator for the message window shared session object */
 @END
 
 
diff --git a/server/window.c b/server/window.c
index afd4564e206..1fe681b5d56 100644
--- a/server/window.c
+++ b/server/window.c
@@ -29,6 +29,7 @@
 #include "winbase.h"
 #include "ntuser.h"
 
+#include "file.h"
 #include "object.h"
 #include "request.h"
 #include "thread.h"
@@ -94,6 +95,7 @@ struct window
     struct property *properties;      /* window properties array */
     int              nb_extra_bytes;  /* number of extra bytes */
     char            *extra_bytes;     /* extra bytes storage */
+    const window_shm_t *shared;       /* window in session shared memory */
 };
 
 static void window_dump( struct object *obj, int verbose );
@@ -180,6 +182,8 @@ static void window_destroy( struct object *obj )
         memset( win->extra_bytes, 0x55, win->nb_extra_bytes );
         free( win->extra_bytes );
     }
+
+    if (win->shared) free_shared_object( win->shared );
 }
 
 /* retrieve a pointer to a window from its handle */
@@ -662,10 +666,18 @@ static struct window *create_window( struct window *parent, struct window *owner
     win->properties     = NULL;
     win->nb_extra_bytes = 0;
     win->extra_bytes    = NULL;
+    win->shared         = NULL;
     win->window_rect = win->visible_rect = win->surface_rect = win->client_rect = empty_rect;
     list_init( &win->children );
     list_init( &win->unlinked );
 
+    if (!(win->shared = alloc_shared_object())) goto failed;
+    SHARED_WRITE_BEGIN( win->shared, window_shm_t )
+    {
+        shared->placeholder = 0;
+    }
+    SHARED_WRITE_END;
+
     if (extra_bytes)
     {
         if (!(win->extra_bytes = mem_alloc( extra_bytes ))) goto failed;
@@ -2204,6 +2216,7 @@ DECL_HANDLER(create_window)
     win->style = req->style;
     win->ex_style = req->ex_style;
 
+    reply->locator     = get_shared_object_locator( win->shared );
     reply->handle      = win->handle;
     reply->parent      = win->parent ? win->parent->handle : 0;
     reply->owner       = win->owner;
@@ -2255,6 +2268,7 @@ DECL_HANDLER(destroy_window)
 DECL_HANDLER(get_desktop_window)
 {
     struct desktop *desktop = get_thread_desktop( current, 0 );
+    struct window *win;
 
     if (!desktop) return;
 
@@ -2279,8 +2293,16 @@ DECL_HANDLER(get_desktop_window)
         }
     }
 
-    reply->top_window = desktop->top_window ? desktop->top_window->handle : 0;
-    reply->msg_window = desktop->msg_window ? desktop->msg_window->handle : 0;
+    if ((win = desktop->top_window))
+    {
+        reply->top_window = win->handle;
+        reply->top_locator = get_shared_object_locator( win->shared );
+    }
+    if ((win = desktop->msg_window))
+    {
+        reply->msg_window = win->handle;
+        reply->msg_locator = get_shared_object_locator( win->shared );
+    }
     release_object( desktop );
 }
 
-- 
GitLab


From ea61e081974631d9d28150596bbbc1182c9e344a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 6 Mar 2025 13:33:50 +0100
Subject: [PATCH 3/4] server: Move the window full handle to the shared memory.

---
 server/protocol.def |   2 +-
 server/window.c     | 124 ++++++++++++++++++++++----------------------
 2 files changed, 64 insertions(+), 62 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 44e952ecc91..2d6c712d8dc 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1009,7 +1009,7 @@ typedef volatile struct
 
 typedef volatile struct
 {
-    int                  placeholder;
+    user_handle_t        handle;           /* full handle for this window */
 } window_shm_t;
 
 typedef volatile union
diff --git a/server/window.c b/server/window.c
index 1fe681b5d56..9357536aebf 100644
--- a/server/window.c
+++ b/server/window.c
@@ -61,7 +61,6 @@ struct window
     struct list      children;        /* list of children in Z-order */
     struct list      unlinked;        /* list of children not linked in the Z-order list */
     struct list      entry;           /* entry in parent's children list */
-    user_handle_t    handle;          /* full handle for this window */
     struct thread   *thread;          /* thread owning the window */
     struct desktop  *desktop;         /* desktop that the window belongs to */
     struct window_class *class;       /* window class */
@@ -157,14 +156,14 @@ static void window_dump( struct object *obj, int verbose )
 {
     struct window *win = (struct window *)obj;
     assert( obj->ops == &window_ops );
-    fprintf( stderr, "window %p handle %x\n", win, win->handle );
+    fprintf( stderr, "window %p handle %x\n", win, win->shared->handle );
 }
 
 static void window_destroy( struct object *obj )
 {
     struct window *win = (struct window *)obj;
 
-    assert( !win->handle );
+    assert( !win->shared->handle );
 
     if (win->parent)
     {
@@ -375,7 +374,7 @@ static int link_window( struct window *win, struct window *previous )
             {
                 struct window *next = LIST_ENTRY( entry, struct window, entry );
                 if (!(next->ex_style & WS_EX_TOPMOST)) break;
-                if (next->handle == win->owner)  /* keep it above owner */
+                if (next->shared->handle == win->owner)  /* keep it above owner */
                 {
                     win->ex_style |= WS_EX_TOPMOST;
                     break;
@@ -565,7 +564,7 @@ static void detach_window_thread( struct window *win )
     {
         if (win->update_region) inc_queue_paint_count( thread, -1 );
         if (win->paint_flags & PAINT_INTERNAL) inc_queue_paint_count( thread, -1 );
-        queue_cleanup_window( thread, win->handle );
+        queue_cleanup_window( thread, win->shared->handle );
     }
     assert( thread->desktop_users > 0 );
     thread->desktop_users--;
@@ -597,7 +596,7 @@ void post_desktop_message( struct desktop *desktop, unsigned int message,
                            lparam_t wparam, lparam_t lparam )
 {
     struct window *win = desktop->top_window;
-    if (win && win->thread) post_message( win->handle, message, wparam, lparam );
+    if (win && win->thread) post_message( win->shared->handle, message, wparam, lparam );
 }
 
 /* create a new window structure (note: the window is not linked in the window tree) */
@@ -608,6 +607,7 @@ static struct window *create_window( struct window *parent, struct window *owner
     struct window *win = NULL;
     struct desktop *desktop;
     struct window_class *class;
+    user_handle_t handle = 0;
 
     if (!(desktop = get_thread_desktop( current, DESKTOP_CREATEWINDOW ))) return NULL;
 
@@ -640,7 +640,7 @@ static struct window *create_window( struct window *parent, struct window *owner
 
     if (!(win = alloc_object( &window_ops ))) goto failed;
     win->parent         = parent ? (struct window *)grab_object( parent ) : NULL;
-    win->owner          = owner ? owner->handle : 0;
+    win->owner          = owner ? owner->shared->handle : 0;
     win->thread         = current;
     win->desktop        = desktop;
     win->class          = class;
@@ -672,9 +672,12 @@ static struct window *create_window( struct window *parent, struct window *owner
     list_init( &win->unlinked );
 
     if (!(win->shared = alloc_shared_object())) goto failed;
+    if (!(handle = alloc_user_handle( win, USER_WINDOW ))) goto failed;
+    win->last_active = win->shared->handle;
+
     SHARED_WRITE_BEGIN( win->shared, window_shm_t )
     {
-        shared->placeholder = 0;
+        shared->handle = handle;
     }
     SHARED_WRITE_END;
 
@@ -684,8 +687,6 @@ static struct window *create_window( struct window *parent, struct window *owner
         memset( win->extra_bytes, 0, extra_bytes );
         win->nb_extra_bytes = extra_bytes;
     }
-    if (!(win->handle = alloc_user_handle( win, USER_WINDOW ))) goto failed;
-    win->last_active = win->handle;
 
     /* if parent belongs to a different thread and the window isn't */
     /* top-level, attach the two threads */
@@ -720,15 +721,8 @@ static struct window *create_window( struct window *parent, struct window *owner
     return win;
 
 failed:
-    if (win)
-    {
-        if (win->handle)
-        {
-            free_user_handle( win->handle );
-            win->handle = 0;
-        }
-        release_object( win );
-    }
+    if (win) release_object( win );
+    if (handle) free_user_handle( handle );
     release_object( desktop );
     release_class( class );
     return NULL;
@@ -793,7 +787,7 @@ int make_window_active( user_handle_t window )
     owner = win;
     while (owner)
     {
-        owner->last_active = win->handle;
+        owner->last_active = win->shared->handle;
         owner = get_user_object( owner->owner, USER_WINDOW );
     }
     return 1;
@@ -922,7 +916,7 @@ static void append_window_to_list( struct window *win, struct thread *thread, at
 {
     if (thread && win->thread != thread) return;
     if (atom && get_class_atom( win->class ) != atom) return;
-    if (*count < max_count) handles[*count] = win->handle;
+    if (*count < max_count) handles[*count] = win->shared->handle;
     (*count)++;
 }
 
@@ -1011,7 +1005,7 @@ static int get_window_children_from_point( struct window *parent, int x, int y,
         }
 
         /* now add window to the array */
-        if (!add_handle_to_array( array, ptr->handle )) return 0;
+        if (!add_handle_to_array( array, ptr->shared->handle )) return 0;
     }
     return 1;
 }
@@ -1030,9 +1024,9 @@ user_handle_t shallow_window_from_point( struct desktop *desktop, int x, int y )
         int x_child = x, y_child = y;
 
         if (!is_point_in_window( ptr, &x_child, &y_child, 0 )) continue;  /* skip it */
-        return ptr->handle;
+        return ptr->shared->handle;
     }
-    return desktop->top_window->handle;
+    return desktop->top_window->shared->handle;
 }
 
 /* return thread of top-most window containing point (in absolute raw coords) */
@@ -1072,7 +1066,7 @@ static int all_windows_from_point( struct window *top, int x, int y, unsigned in
         if (!get_window_children_from_point( top, x, y, array )) return 0;
     }
     /* now add window to the array */
-    if (!add_handle_to_array( array, top->handle )) return 0;
+    if (!add_handle_to_array( array, top->shared->handle )) return 0;
     return 1;
 }
 
@@ -1137,13 +1131,13 @@ user_handle_t find_window_to_repaint( user_handle_t parent, struct thread *threa
     {
         /* check that it is a child of the specified parent */
         for (ptr = win; ptr; ptr = ptr->parent)
-            if (ptr->handle == parent) break;
+            if (ptr->shared->handle == parent) break;
         /* otherwise don't return any window, we don't repaint a child before its parent */
         if (!ptr) win = NULL;
     }
     if (!win) return 0;
     win->paint_flags &= ~PAINT_INTERNAL;
-    return win->handle;
+    return win->shared->handle;
 }
 
 
@@ -2106,8 +2100,9 @@ static void set_window_region( struct window *win, struct region *region, int re
 void free_window_handle( struct window *win )
 {
     struct window *child, *next;
+    user_handle_t handle;
 
-    assert( win->handle );
+    assert( win->shared->handle );
 
     /* hide the window */
     if (is_visible(win))
@@ -2127,19 +2122,19 @@ void free_window_handle( struct window *win )
     /* destroy all children */
     LIST_FOR_EACH_ENTRY_SAFE( child, next, &win->children, struct window, entry )
     {
-        if (!child->handle) continue;
+        if (!child->shared->handle) continue;
         if (!win->thread || !child->thread || win->thread == child->thread)
             free_window_handle( child );
         else
-            send_notify_message( child->handle, WM_WINE_DESTROYWINDOW, 0, 0 );
+            send_notify_message( child->shared->handle, WM_WINE_DESTROYWINDOW, 0, 0 );
     }
     LIST_FOR_EACH_ENTRY_SAFE( child, next, &win->children, struct window, entry )
     {
-        if (!child->handle) continue;
+        if (!child->shared->handle) continue;
         if (!win->thread || !child->thread || win->thread == child->thread)
             free_window_handle( child );
         else
-            send_notify_message( child->handle, WM_WINE_DESTROYWINDOW, 0, 0 );
+            send_notify_message( child->shared->handle, WM_WINE_DESTROYWINDOW, 0, 0 );
     }
 
     /* reset global window pointers, if the corresponding window is destroyed */
@@ -2147,8 +2142,8 @@ void free_window_handle( struct window *win )
     if (win == win->desktop->shell_listview) win->desktop->shell_listview = NULL;
     if (win == win->desktop->progman_window) win->desktop->progman_window = NULL;
     if (win == win->desktop->taskman_window) win->desktop->taskman_window = NULL;
-    free_hotkeys( win->desktop, win->handle );
-    cleanup_clipboard_window( win->desktop, win->handle );
+    free_hotkeys( win->desktop, win->shared->handle );
+    cleanup_clipboard_window( win->desktop, win->shared->handle );
     destroy_properties( win );
     if (is_desktop_window(win))
     {
@@ -2159,14 +2154,21 @@ void free_window_handle( struct window *win )
     }
     else if (is_desktop_window( win->parent ))
     {
-        post_message( win->parent->handle, WM_PARENTNOTIFY, WM_DESTROY, win->handle );
+        post_message( win->parent->shared->handle, WM_PARENTNOTIFY, WM_DESTROY, win->shared->handle );
     }
 
     detach_window_thread( win );
 
     if (win->parent) set_parent_window( win, NULL );
-    free_user_handle( win->handle );
-    win->handle = 0;
+
+    SHARED_WRITE_BEGIN( win->shared, window_shm_t )
+    {
+        handle = win->shared->handle;
+        shared->handle = 0;
+    }
+    SHARED_WRITE_END;
+    free_user_handle( handle );
+
     release_object( win );
 }
 
@@ -2217,8 +2219,8 @@ DECL_HANDLER(create_window)
     win->ex_style = req->ex_style;
 
     reply->locator     = get_shared_object_locator( win->shared );
-    reply->handle      = win->handle;
-    reply->parent      = win->parent ? win->parent->handle : 0;
+    reply->handle      = win->shared->handle;
+    reply->parent      = win->parent ? win->parent->shared->handle : 0;
     reply->owner       = win->owner;
     reply->extra       = win->nb_extra_bytes;
     reply->dpi_context = win->dpi_context;
@@ -2239,8 +2241,8 @@ DECL_HANDLER(set_parent)
         set_error( STATUS_INVALID_PARAMETER );
         return;
     }
-    reply->old_parent  = win->parent->handle;
-    reply->full_parent = parent ? parent->handle : 0;
+    reply->old_parent  = win->parent->shared->handle;
+    reply->full_parent = parent ? parent->shared->handle : 0;
     set_parent_window( win, parent );
     reply->dpi_context = win->dpi_context;
 }
@@ -2295,12 +2297,12 @@ DECL_HANDLER(get_desktop_window)
 
     if ((win = desktop->top_window))
     {
-        reply->top_window = win->handle;
+        reply->top_window = win->shared->handle;
         reply->top_locator = get_shared_object_locator( win->shared );
     }
     if ((win = desktop->msg_window))
     {
-        reply->msg_window = win->handle;
+        reply->msg_window = win->shared->handle;
         reply->msg_locator = get_shared_object_locator( win->shared );
     }
     release_object( desktop );
@@ -2332,7 +2334,7 @@ DECL_HANDLER(set_window_owner)
     }
 
     reply->prev_owner = win->owner;
-    reply->full_owner = win->owner = owner ? owner->handle : 0;
+    reply->full_owner = win->owner = owner ? owner->shared->handle : 0;
 }
 
 
@@ -2343,8 +2345,8 @@ DECL_HANDLER(get_window_info)
 
     if (!win) return;
 
-    reply->full_handle = win->handle;
-    reply->last_active = win->handle;
+    reply->full_handle = win->shared->handle;
+    reply->last_active = win->shared->handle;
     reply->is_unicode  = win->is_unicode;
     reply->dpi_context = win->dpi_context;
 
@@ -2424,7 +2426,7 @@ DECL_HANDLER(get_window_parents)
     if (len && ((data = set_reply_data_size( len ))))
     {
         for (ptr = win->parent; ptr && len; ptr = ptr->parent, len -= sizeof(*data))
-            *data++ = ptr->handle;
+            *data++ = ptr->shared->handle;
     }
 }
 
@@ -2566,18 +2568,18 @@ DECL_HANDLER(get_window_tree)
     if (win->parent)
     {
         struct window *parent = win->parent;
-        reply->parent = parent->handle;
+        reply->parent = parent->shared->handle;
         reply->owner  = win->owner;
         if (win->is_linked)
         {
-            if ((ptr = get_next_window( win ))) reply->next_sibling = ptr->handle;
-            if ((ptr = get_prev_window( win ))) reply->prev_sibling = ptr->handle;
+            if ((ptr = get_next_window( win ))) reply->next_sibling = ptr->shared->handle;
+            if ((ptr = get_prev_window( win ))) reply->prev_sibling = ptr->shared->handle;
         }
-        if ((ptr = get_first_child( parent ))) reply->first_sibling = ptr->handle;
-        if ((ptr = get_last_child( parent ))) reply->last_sibling = ptr->handle;
+        if ((ptr = get_first_child( parent ))) reply->first_sibling = ptr->shared->handle;
+        if ((ptr = get_last_child( parent ))) reply->last_sibling = ptr->shared->handle;
     }
-    if ((ptr = get_first_child( win ))) reply->first_child = ptr->handle;
-    if ((ptr = get_last_child( win ))) reply->last_child = ptr->handle;
+    if ((ptr = get_first_child( win ))) reply->first_child = ptr->shared->handle;
+    if ((ptr = get_last_child( win ))) reply->last_child = ptr->shared->handle;
 }
 
 
@@ -2668,7 +2670,7 @@ DECL_HANDLER(set_window_pos)
     reply->new_ex_style = win->ex_style;
 
     top = get_top_clipping_window( win );
-    if (is_visible( top ) && (top->paint_flags & PAINT_HAS_SURFACE)) reply->surface_win = top->handle;
+    if (is_visible( top ) && (top->paint_flags & PAINT_HAS_SURFACE)) reply->surface_win = top->shared->handle;
 }
 
 
@@ -2793,7 +2795,7 @@ DECL_HANDLER(get_visible_region)
         data = get_region_data_and_free( region, get_reply_max_size(), &reply->total_size );
         if (data) set_reply_data_ptr( data, reply->total_size );
     }
-    reply->top_win  = top->handle;
+    reply->top_win  = top->shared->handle;
     reply->top_rect = top->surface_rect;
 
     if (!is_desktop_window(win))
@@ -2908,7 +2910,7 @@ DECL_HANDLER(get_update_region)
     }
 
     reply->flags = get_window_update_flags( win, from_child, flags, &win );
-    reply->child = win->handle;
+    reply->child = win->shared->handle;
 
     if (flags & UPDATE_NOREGION) return;
 
@@ -3127,10 +3129,10 @@ DECL_HANDLER(set_desktop_shell_windows)
     new_progman_window = desktop->progman_window;
     new_taskman_window = desktop->taskman_window;
 
-    reply->old_shell_window   = new_shell_window ? new_shell_window->handle : 0;
-    reply->old_shell_listview = new_shell_listview ? new_shell_listview->handle : 0;
-    reply->old_progman_window = new_progman_window ? new_progman_window->handle : 0;
-    reply->old_taskman_window = new_taskman_window ? new_taskman_window->handle : 0;
+    reply->old_shell_window   = new_shell_window ? new_shell_window->shared->handle : 0;
+    reply->old_shell_listview = new_shell_listview ? new_shell_listview->shared->handle : 0;
+    reply->old_progman_window = new_progman_window ? new_progman_window->shared->handle : 0;
+    reply->old_taskman_window = new_taskman_window ? new_taskman_window->shared->handle : 0;
 
     if (req->flags & SET_DESKTOP_SHELL_WINDOWS)
     {
-- 
GitLab


From e6206ac066c76157f35881de2189e5d90cdb47ac Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 6 Mar 2025 10:05:38 +0100
Subject: [PATCH 4/4] win32u: Read the windows full handle from the shared
 memory.

---
 dlls/win32u/win32u_private.h |  1 +
 dlls/win32u/window.c         | 31 +++++------------
 dlls/win32u/winstation.c     | 64 ++++++++++++++++++++++++++++++++++++
 server/hook.c                |  2 +-
 server/protocol.def          |  9 ++++-
 server/user.c                | 18 ++++++++--
 server/user.h                |  2 +-
 server/window.c              |  3 +-
 8 files changed, 100 insertions(+), 30 deletions(-)

diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 3bdfa47b439..a85f0b2e292 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -222,6 +222,7 @@ struct object_lock
 extern NTSTATUS get_shared_desktop( struct object_lock *lock, const desktop_shm_t **desktop_shm );
 extern NTSTATUS get_shared_queue( struct object_lock *lock, const queue_shm_t **queue_shm );
 extern NTSTATUS get_shared_input( UINT tid, struct object_lock *lock, const input_shm_t **input_shm );
+extern NTSTATUS get_shared_window( HWND hwnd, struct object_lock *lock, const window_shm_t **window_shm );
 extern void set_shared_user_object( HANDLE handle, struct obj_locator locator );
 
 extern BOOL is_virtual_desktop(void);
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 6dbfaebb497..1eb8c5f40e9 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -182,36 +182,21 @@ HWND get_hwnd_message_parent(void)
  */
 HWND get_full_window_handle( HWND hwnd )
 {
-    WND *win;
+    struct object_lock lock = OBJECT_LOCK_INIT;
+    const window_shm_t *window_shm;
+    HWND handle = hwnd;
+    UINT status;
 
     if (!hwnd || (ULONG_PTR)hwnd >> 16) return hwnd;
     if (LOWORD(hwnd) <= 1 || LOWORD(hwnd) == 0xffff) return hwnd;
     /* do sign extension for -2 and -3 */
     if (LOWORD(hwnd) >= (WORD)-3) return (HWND)(LONG_PTR)(INT16)LOWORD(hwnd);
 
-    if (!(win = get_win_ptr( hwnd ))) return hwnd;
-
-    if (win == WND_DESKTOP)
-    {
-        if (LOWORD(hwnd) == LOWORD(get_desktop_window())) return get_desktop_window();
-        else return get_hwnd_message_parent();
-    }
+    while ((status = get_shared_window( hwnd, &lock, &window_shm )) == STATUS_PENDING)
+        handle = wine_server_ptr_handle( window_shm->handle );
+    if (status) return hwnd;
 
-    if (win != WND_OTHER_PROCESS)
-    {
-        hwnd = win->obj.handle;
-        release_win_ptr( win );
-    }
-    else  /* may belong to another process */
-    {
-        SERVER_START_REQ( get_window_info )
-        {
-            req->handle = wine_server_user_handle( hwnd );
-            if (!wine_server_call_err( req )) hwnd = wine_server_ptr_handle( reply->full_handle );
-        }
-        SERVER_END_REQ;
-    }
-    return hwnd;
+    return handle;
 }
 
 /*******************************************************************
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index 5850f1121f0..8060e4fb469 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -354,6 +354,70 @@ void set_shared_user_object( HANDLE handle, struct obj_locator locator )
     pthread_mutex_unlock( &user_objects_lock );
 }
 
+static NTSTATUS get_shared_user_object( HANDLE handle, unsigned int type, struct object_lock *lock,
+                                        const object_shm_t **object_shm )
+{
+    WORD index = USER_HANDLE_TO_INDEX( handle );
+    struct shared_user_object_cache *cache;
+    const shared_object_t *object;
+    UINT status = STATUS_SUCCESS;
+    BOOL valid = TRUE;
+
+    if (index >= NB_USER_HANDLES) return STATUS_INVALID_PARAMETER;
+    cache = user_objects + index;
+
+    pthread_mutex_lock( &user_objects_lock );
+    if (!(object = cache->object))
+    {
+        struct obj_locator locator;
+
+        SERVER_START_REQ( get_shared_user_object )
+        {
+            req->handle = wine_server_user_handle( handle );
+            req->type = type;
+            wine_server_call( req );
+            locator = reply->locator;
+        }
+        SERVER_END_REQ;
+
+        cache->id = locator.id;
+        cache->object = find_shared_session_object( locator );
+        if (!(object = cache->object)) status = STATUS_INVALID_HANDLE;
+        memset( lock, 0, sizeof(*lock) );
+    }
+
+    /* check object validity by comparing ids, within the object seqlock */
+    if (!status) valid = cache->id == object->id;
+    pthread_mutex_unlock( &user_objects_lock );
+
+    if (!status && (!lock->id || !shared_object_release_seqlock( object, lock->seq )))
+    {
+        shared_object_acquire_seqlock( object, &lock->seq );
+        if (!(lock->id = object->id)) lock->id = -1;
+        *object_shm = &object->shm;
+        return STATUS_PENDING;
+    }
+
+    if (!valid)
+    {
+        memset( cache, 0, sizeof(*cache) ); /* object has been invalidated, clear the cache */
+        return STATUS_INVALID_HANDLE;
+    }
+    return status;
+}
+
+NTSTATUS get_shared_window( HWND hwnd, struct object_lock *lock, const window_shm_t **window_shm )
+{
+    const object_shm_t *object_shm;
+    UINT status = STATUS_SUCCESS;
+
+    TRACE( "hwnd %p, lock %p, input_shm %p\n", hwnd, lock, window_shm );
+
+    status = get_shared_user_object( hwnd, NTUSER_OBJ_WINDOW, lock, &object_shm );
+    if (status == STATUS_PENDING) *window_shm = &object_shm->window;
+    return status;
+}
+
 BOOL is_virtual_desktop(void)
 {
     struct object_lock lock = OBJECT_LOCK_INIT;
diff --git a/server/hook.c b/server/hook.c
index ffe7206369e..4583dc3f206 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -153,7 +153,7 @@ static struct hook *add_hook( struct desktop *desktop, struct process *process,
     }
     if (!(hook = mem_alloc( sizeof(*hook) ))) return NULL;
 
-    if (!(hook->handle = alloc_user_handle( hook, USER_HOOK )))
+    if (!(hook->handle = alloc_user_handle( hook, USER_HOOK, NULL )))
     {
         free( hook );
         return NULL;
diff --git a/server/protocol.def b/server/protocol.def
index 2d6c712d8dc..bb4e66aedb2 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2578,7 +2578,6 @@ enum message_type
 @REQ(get_window_info)
     user_handle_t  handle;      /* handle to the window */
 @REPLY
-    user_handle_t  full_handle; /* full 32-bit handle */
     user_handle_t  last_active; /* last active popup */
     process_id_t   pid;         /* process owning the window */
     thread_id_t    tid;         /* thread owning the window */
@@ -2982,6 +2981,14 @@ enum coords_relative
 @END
 
 
+@REQ(get_shared_user_object)
+    obj_handle_t handle;          /* handle to the object */
+    unsigned int type;            /* expected type of the object */
+@REPLY
+    struct obj_locator locator;
+@END
+
+
 /* Get/set information about a user object (window station or desktop) */
 @REQ(set_user_object_info)
     obj_handle_t handle;          /* handle to the object */
diff --git a/server/user.c b/server/user.c
index 2d038a6ddbf..163db4f20af 100644
--- a/server/user.c
+++ b/server/user.c
@@ -20,11 +20,13 @@
 
 #include "thread.h"
 #include "user.h"
+#include "file.h"
 #include "request.h"
 
 struct user_handle
 {
     void          *ptr;          /* pointer to object */
+    const volatile void *shm;    /* object shared memory */
     unsigned short type;         /* object type (0 if free) */
     unsigned short generation;   /* generation counter */
 };
@@ -84,17 +86,19 @@ static inline void *free_user_entry( struct user_handle *ptr )
     void *ret;
     ret = ptr->ptr;
     ptr->ptr  = freelist;
+    ptr->shm  = NULL;
     ptr->type = 0;
     freelist  = ptr;
     return ret;
 }
 
 /* allocate a user handle for a given object */
-user_handle_t alloc_user_handle( void *ptr, enum user_object type )
+user_handle_t alloc_user_handle( void *ptr, enum user_object type, const volatile void *object_shm )
 {
     struct user_handle *entry = alloc_user_entry();
     if (!entry) return 0;
     entry->ptr  = ptr;
+    entry->shm  = object_shm;
     entry->type = type;
     if (++entry->generation >= 0xffff) entry->generation = 1;
     return entry_to_handle( entry );
@@ -179,7 +183,7 @@ void free_process_user_handles( struct process *process )
 /* allocate an arbitrary user handle */
 DECL_HANDLER(alloc_user_handle)
 {
-    reply->handle = alloc_user_handle( current->process, USER_CLIENT );
+    reply->handle = alloc_user_handle( current->process, USER_CLIENT, NULL );
 }
 
 
@@ -193,3 +197,13 @@ DECL_HANDLER(free_user_handle)
     else
         set_error( STATUS_INVALID_HANDLE );
 }
+
+DECL_HANDLER(get_shared_user_object)
+{
+    struct user_handle *entry;
+
+    if (!(entry = handle_to_entry( req->handle )) || entry->type != req->type || !entry->shm)
+        set_error( STATUS_INVALID_HANDLE );
+    else
+        reply->locator = get_shared_object_locator( entry->shm );
+}
diff --git a/server/user.h b/server/user.h
index ce463b9395d..327fc25c427 100644
--- a/server/user.h
+++ b/server/user.h
@@ -99,7 +99,7 @@ struct desktop
 
 /* user handles functions */
 
-extern user_handle_t alloc_user_handle( void *ptr, enum user_object type );
+extern user_handle_t alloc_user_handle( void *ptr, enum user_object type, const volatile void *object_shm );
 extern void *get_user_object( user_handle_t handle, enum user_object type );
 extern void *get_user_object_handle( user_handle_t *handle, enum user_object type );
 extern user_handle_t get_user_full_handle( user_handle_t handle );
diff --git a/server/window.c b/server/window.c
index 9357536aebf..f69e79b5d64 100644
--- a/server/window.c
+++ b/server/window.c
@@ -672,7 +672,7 @@ static struct window *create_window( struct window *parent, struct window *owner
     list_init( &win->unlinked );
 
     if (!(win->shared = alloc_shared_object())) goto failed;
-    if (!(handle = alloc_user_handle( win, USER_WINDOW ))) goto failed;
+    if (!(handle = alloc_user_handle( win, USER_WINDOW, win->shared ))) goto failed;
     win->last_active = win->shared->handle;
 
     SHARED_WRITE_BEGIN( win->shared, window_shm_t )
@@ -2345,7 +2345,6 @@ DECL_HANDLER(get_window_info)
 
     if (!win) return;
 
-    reply->full_handle = win->shared->handle;
     reply->last_active = win->shared->handle;
     reply->is_unicode  = win->is_unicode;
     reply->dpi_context = win->dpi_context;
-- 
GitLab

